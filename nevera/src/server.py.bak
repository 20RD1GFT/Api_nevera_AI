import pandas as pd
from flask import Flask, jsonify, request
from flask_restplus import Api, Resource
import base64
from datetime import datetime
from skimage import color
from skimage import io
import requests


import tensorflow as tf
from keras.models import model_from_json
import tensorflow.keras.applications.inception_resnet_v2
import tensorflow.python.keras.applications.inception_resnet_v2 
import numpy as np
from PIL import Image
from keras.layers import Lambda
import PIL

from swagger.app import blueprint as app_endpoints

import argparse

import os

import numpy as np
import mxnet as mx
import matplotlib.pyplot as plt
import gluoncv as gcv

from mxnet import gluon, autograd
from mxnet.gluon import nn

from mxnet.gluon.data.vision import transforms

from gluoncv import model_zoo, utils

from gluoncv.data import batchify

ctx = [mx.cpu()]


net = model_zoo.get_model('yolo3_darknet53_coco', pretrained=True, ctx=ctx)

base_classes = ['bowl',
                'cup',
                'banana',
                'apple',
                'sandwich',
                'orange',
                'broccoli',
                'carrot',
                'hot dog',
                'pizza',
                'donut',
                'cake',
                'bottle']


net.reset_class(classes=base_classes, reuse_weights=base_classes)

params_path = './models/'
symbol_file = os.path.join(params_path, 'ResNet50_v2_epochs50-lr0.001-wd0.001-symbol.json')
params_file = os.path.join(params_path, 'ResNet50_v2_epochs50-lr0.001-wd0.001-0000.params')

food_classes = ['borscht', 'lagman', 'manty', 'plov', 'samsy']

all_classes = base_classes + food_classes

food_net = nn.SymbolBlock.imports(symbol_file, ['data'], params_file, ctx=ctx)

transform_fn = transforms.Compose([
    transforms.Resize(224),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])
'''
x, orig_img = gcv.data.transforms.presets.yolo.load_test('/content/test1.jpg')

box_ids, scores, bboxes = net.forward(x)

box_ids_np, scores_np, bboxes_np = box_ids[0].asnumpy(), scores[0].asnumpy(), bboxes[0].asnumpy()

bowl_mask = ((box_ids_np == 0) & (scores_np > 0.5))

bowl_ids = np.where(bowl_mask)

bowl_boxes = bboxes_np[bowl_mask.ravel(), :]

if (len(bowl_boxes) > 0):
    bowl_images = [orig_img[int(box[1]): int(box[3]), int(box[0]): int(box[2])] for box in bowl_boxes.tolist()]

    bowl_batch_img = batchify.Stack()([transform_fn(mx.nd.array(img)) for img in bowl_images]).copyto(ctx[0])

    food_outputs = mx.nd.softmax(food_net(bowl_batch_img))

    food_scores = food_outputs.max(axis=1)

    food_labels = food_outputs.argmax(axis=1) + len(base_classes)

    all_classes = base_classes + food_classes

    box_ids = np.delete(box_ids_np, bowl_ids[0], axis=0)
    scores = np.delete(scores_np, bowl_ids[0], axis=0)
    bboxes = np.delete(bboxes_np, bowl_ids[0], axis=0)

    box_ids = np.concatenate((box_ids, food_labels.asnumpy().reshape(-1, 1)), axis=0)
    scores = np.concatenate((scores, food_scores.asnumpy().reshape(-1, 1)), axis=0)
    bboxes = np.concatenate((bboxes, bowl_boxes.reshape(-1, 4)), axis=0)

if (False):
    confident_mask = (scores >= threshold)
    confident_classes = box_ids[confident_mask]
    confident_scores = scores[confident_mask]
    confident_boxes = bboxes[confident_mask.ravel()]

    for i in range(len(confident_boxes)):
        print(f"{all_classes[int(confident_classes[i])]:10} \t {confident_scores[i]:.5f}\t{confident_boxes[i]}")
    

utils.viz.plot_bbox(orig_img,
                    bboxes,
                    scores,
                    box_ids,
                    class_names=all_classes,
                    thresh=0.1)
'''
'''
# plt.rc('figure', figsize=(20,20))
fig = plt.gcf()
fig.set_size_inches(15, 10)
plt.axis('off')
plt.savefig(f"/content/predictions/hola", dpi=300, bbox_inches='tight', pad_inches=0)
'''
'''
### Comment these lines if swagger is not working. 
# app
'''
flask_app = Flask(__name__)
api = Api(app = flask_app)
'''
#app.config["RESTPLUS_MASK_SWAGGER"] = False
#app.register_blueprint(app_endpoints)

#name_space = app.namespace('funciono', description = 'Main API')

from keras.models import load_model
model = load_model("./models/modelo2.h5")


 # Assigning label names to the corresponding indexes
labels = {
    0: 'Bread', 
    1: 'Dairy product', 
    2: 'Dessert', 
    3: 'Egg', 
    4: 'Fried food', 
    5: 'Meat',
    6: 'Noodles-Pasta',
    7: 'Rice', 
    8: 'Seafood',
    9: 'Soup',
    10: 'Vegetable-Fruit'
}


class prediction_test(Resource):
    def get(self):
        return{"queloque": "tu sabras, amigo, alla tu, esto es un post"}
#en este def deber√≠a de entrar la imagen como argumento
    def post(self):
        data = request.get_json(force = True)
        img  = data["message"]
        base64_img_bytes = img.encode("utf-8")
        decoded_image_data = base64.decodebytes(base64_img_bytes)
        with open("imagenes/prueba.jpg", "wb") as file_to_save:  # bucket_
            decoded_image_data = base64.decodebytes(base64_img_bytes)
            file_to_save.write(decoded_image_data)
        # procesado total-----
        img= PIL.Image.open('imagenes/prueba.jpg')
        #resizing the image to (256,256)
        img = img.resize((256,256))
        #converting image to array
        img = np.asarray(img, dtype= np.float32)
        #normalizing the image
        img = img / 255
        #reshaping the image in to a 4D array
        img = img.reshape(-1,256,256,3)
        #making prediction of the model
        predict = model.predict(img)
        #getting the index corresponding to the highest value in the prediction
        predict = np.argmax(predict)
        respond = labels[predict]
        return jsonify({"about": "Prueba guardada e imagen predicha, jaja que bien, la verdad. Vaya alivio. Estoy a punto de llorar",
                        'respuesta': respond})
'''
api.add_resource(prediction_test, "/funciono")

if __name__ == "__main__":
    flask_app.run(port=5000, debug=True, host="0.0.0.0")